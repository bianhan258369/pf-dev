MODULE main

VAR
request:boolean;
inquiry:boolean;
responseOfTrack:boolean;
checkSucc:boolean;
checkFail:boolean;
startUnoccupied:boolean;
startOccupied:boolean;
redPulse:boolean;
greenPulse:boolean;
showGreen:boolean;
showRed:boolean;
wait:boolean;
enter:boolean;
responseOfTrain:boolean;
leave:boolean;

ctr1:strictpre(request,inquiry,5);
ctr2:unionn(checkSucc,checkFail,responseOfTrack);
ctr3:strictpre(checkFail,redPulse,5);
ctr4:strictpre(checkSucc,greenPulse,5);
ctr5:cause(greenPulse,showGreen,5);
ctr6:cause(redPulse,showRed,5);
ctr7:strictpre(showRed,wait,5);
ctr8:strictpre(showGreen,enter,5);
ctr9:unionn(enter,wait,responseOfTrain);
ctr10:Alter(request,responseOfTrain);
ctr11:exclusion(startOccupied,startUnoccupied);
ctr12:exclusion(checkSucc,checkFail);
ctr13:strictpre(enter,leave,5);
ctr14:coincidence(enter,startOccupied);
ctr15:coincidence(leave,startUnoccupied);
ctr16:boundeddiff(inquiry,responseOfTrack,0,40);
ctr17:boundeddiff(greenPulse,showGreen,0,30);
ctr18:boundeddiff(redPulse,showRed,0,30);
ctr19:boundeddiff(request,responseOfTrain,0,50);
ctr20:boundeddiff(checkFail,showRed,0,40);
ctr21:boundeddiff(checkSucc,showGreen,0,40);

ASSIGN
init(request) := FALSE;
init(inquiry) := FALSE;
init(responseOfTrack) := FALSE;
init(checkSucc) := FALSE;
init(checkFail) := FALSE;
init(startUnoccupied) := FALSE;
init(startOccupied) := FALSE;
init(redPulse) := FALSE;
init(greenPulse) := FALSE;
init(showGreen) := FALSE;
init(showRed) := FALSE;
init(wait) := FALSE;
init(enter) := FALSE;
init(responseOfTrain) := FALSE;
init(leave) := FALSE;
CTLSPEC ( ! EF AG !( request|inquiry|responseOfTrack|checkSucc|checkFail|startUnoccupied|startOccupied|redPulse|greenPulse|showGreen|showRed|wait|enter|responseOfTrain|leave ) )

MODULE strictpre(left,right,n)
VAR
	coun:0..n;
INIT
	coun=0;
TRANS
case
	coun=0: (next(left)=TRUE & next(right)=FALSE & next(coun)=coun+1)|(next(left)=FALSE & next(right)=FALSE & next(coun)=coun);
	coun<n: (next(left)=TRUE & next(right)=FALSE & next(coun)=coun+1)|(next(left)=TRUE & next(right)=TRUE & next(coun)=coun)|(next(left)=FALSE & next(right)=TRUE & next(coun)=coun - 1)|(next(left)=FALSE & next(right)=FALSE & next(coun)=coun);
	TRUE: (next(left)=TRUE & next(right)=TRUE & next(coun)=coun)|(next(left)=FALSE & next(right)=TRUE & next(coun)=coun - 1)|(next(left)=FALSE & next(right)=FALSE & next(coun)=coun);
esac


MODULE unionn(left,right,new)
TRANS
	(next(left)=TRUE & next(new)=TRUE)|(next(right)=TRUE & next(new)=TRUE)|(next(left)=FALSE & next(right)=FALSE & next(new)=FALSE)

MODULE boundeddiff(left,right,i,j)
VAR
dif: i..j;
INIT
dif=0
TRANS
case
dif=j:((next(left)=FALSE&next(right)=TRUE&next(dif)=dif - 1) | (next(left)=TRUE&next(right)=TRUE&next(dif)=dif) | (next(left)=FALSE&next(right)=FALSE&next(dif)=dif));
dif=i:((next(left)=TRUE&next(right)=FALSE&next(dif)=dif+1) | (next(left)=TRUE&next(right)=TRUE&next(dif)=dif) | (next(left)=FALSE&next(right)=FALSE&next(dif)=dif));
TRUE:(next(left)=TRUE&next(right)=FALSE&next(dif)=dif+1) | (next(left)=FALSE&next(right)=TRUE&next(dif)=dif - 1) | (next(left)=TRUE&next(right)=TRUE&next(dif)=dif) | (next(left)=FALSE&next(right)=FALSE&next(dif)=dif);
esac

MODULE cause(left,right,n)
VAR
scnt:0..n;
INIT
scnt=0
TRANS
case
scnt=0:((next(left)=TRUE&next(right)=FALSE&next(scnt)=scnt+1) | (next(left)=FALSE&next(right)=FALSE&next(scnt)=scnt) | (next(left)=TRUE&next(right)=TRUE&next(scnt)=scnt));
scnt>0&scnt<n:(next(left)=TRUE&next(right)=FALSE&next(scnt)=scnt+1) | (next(left)=TRUE&next(right)=TRUE&next(scnt)=scnt) | (next(left)=FALSE&next(right)=TRUE&next(scnt)=scnt - 1) | (next(left)=FALSE&next(right)=FALSE&
next(scnt)=scnt);
scnt=n:(next(left)=TRUE&next(right)=TRUE&next(scnt)=scnt) | (next(left)=FALSE&next(right)=TRUE&next(scnt)=scnt - 1) | (next(left)=FALSE&next(right)=FALSE&next(scnt)=scnt);

esac 

MODULE coincidence(left,right)
TRANS
next(left)->next(right)&next(right)->next(left)

MODULE subclock(left,right)
TRANS
      next(left)->next(right)

MODULE delay(left,right,k)
VAR
	cnt:0..k;
INIT
	cnt=0;
TRANS
case
	cnt<k: next(left)=FALSE & ((next(right)=TRUE & next(cnt)=cnt+1)|(next(right)=FALSE & next(cnt)=cnt));
	cnt=k|cnt>k: (next(left)=TRUE & next(right)=TRUE & next(cnt)=cnt)|(next(left)=FALSE & next(right)=FALSE & next(cnt)=cnt);

esac

MODULE exclusion (left, right)
TRANS
(next (left)=TRUE & next (right)=FALSE) | (next(left)=FALSE & next (right)=TRUE)| (next(left)=FALSE & next (right)=FALSE);

MODULE Alter(left,right)
VAR
	state:boolean;
INIT
	state=FALSE;
TRANS
case
    state = FALSE :  (next(right)=FALSE & next(left)=TRUE  & next(state) = TRUE )|(next(right)=FALSE & next(left)=FALSE & next(state)=FALSE);
    state = TRUE :  (next(left)=FALSE & next(right)=TRUE  & next(state) = FALSE)|(next(left)=FALSE & next(right)=FALSE & next(state)=TRUE);

esac
